import { Resend } from 'resend';
import { generateInvoiceEmailHTML, generateInvoiceEmailText, type EmailTemplateData } from './templates';
import { env } from '$env/dynamic/private';

// Initialize Resend client (handle missing key gracefully)
const resend = env.RESEND_API_KEY ? new Resend(env.RESEND_API_KEY) : null;

export interface SendInvoiceEmailOptions {
  to: string;
  from?: string;
  replyTo?: string;
  subject?: string;
  attachmentBuffer?: Buffer;
  attachmentFilename?: string;
}

export interface EmailDeliveryResult {
  success: boolean;
  messageId?: string;
  error?: string;
}

/**
 * Send an invoice email with PDF attachment
 */
export async function sendInvoiceEmail(
  templateData: EmailTemplateData,
  options: SendInvoiceEmailOptions
): Promise<EmailDeliveryResult> {
  try {
    // Validate required fields
    if (!resend) {
      throw new Error('RESEND_API_KEY is not configured');
    }

    if (!options.to) {
      throw new Error('Recipient email is required');
    }

    // Generate email content
    const htmlContent = generateInvoiceEmailHTML(templateData);
    const textContent = generateInvoiceEmailText(templateData);

    // Prepare email payload
    const emailPayload: any = {
      from: options.from || 'Invoices <onboarding@resend.dev>',
      to: [options.to],
      subject: options.subject || `Invoice ${templateData.invoiceNumber} from ${templateData.companyName}`,
      html: htmlContent,
      text: textContent,
      replyTo: options.replyTo
    };

    // Add PDF attachment if provided
    if (options.attachmentBuffer && options.attachmentFilename) {
      emailPayload.attachments = [
        {
          filename: options.attachmentFilename,
          content: options.attachmentBuffer
        }
      ];
    }

    // Send email using Resend
    const { data, error } = await resend.emails.send(emailPayload);

    if (error) {
      console.error('Resend API error:', error);
      return {
        success: false,
        error: error.message || 'Email sending failed'
      };
    }

    return {
      success: true,
      messageId: data?.id
    };

  } catch (error) {
    console.error('Email service error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown email error'
    };
  }
}

/**
 * Send a test email to verify configuration
 */
export async function sendTestEmail(to: string): Promise<EmailDeliveryResult> {
  try {
    const { data, error } = await resend.emails.send({
      from: 'inv <onboarding@resend.dev>',
      to: [to],
      subject: 'Test Email from inv',
      html: `
        <div style="font-family: sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
          <h1>Test Email Successful!</h1>
          <p>This is a test email from your inv application.</p>
          <p>Email service is configured correctly and ready to send invoice emails.</p>
          <hr>
          <p style="color: #666; font-size: 12px;">Generated by inv â€¢ Beautiful invoices for designers</p>
        </div>
      `,
      text: 'Test Email Successful!\n\nThis is a test email from your inv application.\n\nEmail service is configured correctly and ready to send invoice emails.'
    });

    if (error) {
      return {
        success: false,
        error: error.message || 'Test email failed'
      };
    }

    return {
      success: true,
      messageId: data?.id
    };

  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Test email error'
    };
  }
}

/**
 * Check if email service is properly configured
 */
export function isEmailServiceConfigured(): boolean {
  return Boolean(env.RESEND_API_KEY);
}

/**
 * Get email service status
 */
export async function getEmailServiceStatus(): Promise<{
  configured: boolean;
  working?: boolean;
  error?: string;
}> {
  const configured = isEmailServiceConfigured();
  
  if (!configured) {
    return {
      configured: false,
      error: 'RESEND_API_KEY not configured'
    };
  }

  // We could add a health check here if needed
  return {
    configured: true,
    working: true
  };
}